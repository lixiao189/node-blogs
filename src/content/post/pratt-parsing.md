---
title: "Pratt Parsing åŸºäº Python å®ç°"
publishDate: "14 May 2025"
description: "Pratt Parsing æ˜¯ä¸€ä¸ªç”¨æ¥åœ¨é€’å½’å‘ä¸‹ç¼–è¯‘å™¨å‰ç«¯ä¸­è§£å†³è¡¨è¾¾å¼è§£æçš„ä¸€ä¸ªå·¥å…·"
tags: ["compiler"]
---

> - æœ¬æ–‡å†…å®¹å—åˆ°è¿™ç¯‡åšå®¢å¯å‘: <https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html>
> - å®Œæ•´çš„ Python å®ç°ï¼š<https://gist.github.com/lixiao189/c45ae6891ccfe57cbd431ced8eb63b74>

## ç¼–è¯‘å™¨å‰ç«¯ Parsing

ç¼–è¯‘å™¨å‰ç«¯ parsing çš„ä½œç”¨ä¸»è¦æ˜¯å°†æˆ‘ä»¬çš„ä»£ç ç¿»è¯‘æˆä¸€ä¸ªï¼Œä¸€ä¸ªâ€¦â€¦ è¯­æ³•æ ‘å•Šå•Šå•Šå•Šå•Š

```txt
                            Add
                 Parser     / \
 "1 + 2 * 3"    ------->   1  Mul
                              / \
                             2   3
```

## BNF

åœ¨å·¥åœ°ä¸Šç¼–è¯‘åŸç†çš„æ—¶å€™è¯­æ³•è²Œä¼¼ä¸æ˜¯ç”¨è¿™ä¸ªä¸œè¥¿è¡¨è¾¾çš„ï¼Œåœ¨è¿™é‡Œç‹ ç‹ çš„ä»‹ç»ä¸€ä¸‹

```txt
Item =
    StructItem
  | EnumItem
  | ...

StructItem =
    'struct' Name '{' FieldList '}'
```

è¿™å°±æ˜¯ä¸€ä¸ªå¸¸è§çš„ BNF è¡¨ç¤ºçš„è¯­æ³•ï¼Œç­‰å·å·¦è¾¹æ˜¯ä¸€ä¸ªéç»ˆç»“ç¬¦ï¼Œç„¶åå³è¾¹æ˜¯è¿™ä¸ªéç»ˆç»“ç¬¦
æ¨å€’å‡ºæ¥çš„ä¸œè¥¿ï¼Œ`|` æˆ‘ç†è§£æ˜¯æˆ–çš„æ„æ€ï¼Œç”¨æ¥åˆ†å‰²å¼€ç”Ÿæˆçš„å…¶ä»–å¯èƒ½çš„æƒ…å†µ

## è§£å†³é—®é¢˜

è‡ªé¡¶å‘ä¸‹è§£æå™¨æ˜¯ä¸€ä¸ªå¯ä»¥ç”¨æ¥æ‰‹å†™å®ç°çš„ç¼–è¯‘å™¨å‰ç«¯ï¼Œæ¯”è¾ƒæ–¹ä¾¿ç”¨æ¥å­¦ä¹ ã€‚
åœ¨è‡ªé¡¶å‘ä¸‹çš„ç¼–è¯‘å™¨å‰ç«¯ä¸­ï¼Œæˆ‘ä»¬å¾€å¾€éœ€è¦è§£å†³è¡¨è¾¾å¼è§£æäºŒä¹‰æ€§çš„é—®é¢˜ã€‚
æ¯”å¦‚è¯´æˆ‘ä»¬ä¸‹é¢çš„ä¸€ä¸ªè¡¨è¾¾å¼è§£æ

```txt
 "1 + 2 * 3"
```

æ‰€è°“çš„äºŒä¹‰æ€§å°±æ˜¯å› ä¸ºè¯­æ³•å®šä¹‰ä¸æ­£ç¡®ï¼Œå¯¼è‡´ä¸Šé¢çš„è¡¨è¾¾å¼æœ‰ä¸¤ç§è§£ææ–¹å¼

å‡å¦‚è¯´æˆ‘ä»¬æœ‰å¦‚ä¸‹çš„è¯­æ³•ï¼š

```txt
Expr =
    Expr '+' Expr
  | Expr '*' Expr
  | '(' Expr ')'
  | 'number'
```

ä¸Šé¢è¿™ä¸ªè¯­æ³•å°±æ˜¯æœ‰äºŒä¹‰æ€§çš„ï¼Œæˆ‘ä»¬å¯ä»¥æœ‰ä¸¤ç§æ¨å¯¼æ–¹å¼

```txt
                  Add         Mul
                  / \         / \
 "1 + 2 * 3"     1  Mul      Add 3
                    / \      / \
                   2   3    1   2
```

è¿™å°±æ˜¯æ²¡æœ‰åœ¨è¯­æ³•ä¸­ä½“ç°è¿ç®—ç¬¦ä¼˜å…ˆçº§ï¼Œç„¶åå¯¼è‡´ä½ çš„ä»£ç æœ‰ä¸¤ç§è§£ææ–¹å¼ï¼Œè¿™æ ·è‚¯å®šå°±ä¼š
å¯¼è‡´æœ€åç¼–è¯‘çš„äº§ç‰©æœ‰ä¸¤ç§å¯èƒ½ï¼Œè¿™å¥½å—ï¼Œè¿™ä¸å¥½ã€‚

åŒæ—¶æˆ‘ä»¬è¿˜æœŸæœ›ç”Ÿæˆçš„**è¯­æ³•æ ‘è¶Šæ·±çš„ç»“ç‚¹è¿ç®—ä¼˜å…ˆçº§è¶Šé«˜**ã€‚
æˆ‘ä»¬æœ€ååªæœŸæœ›å‡ºç°å·¦è¾¹çš„è§£æç»“æœã€‚

```txt
Expr =
    Factor
  | Expr '+' Factor

Factor =
    Atom
  | Factor '*' Atom

Atom =
    'number'
  | '(' Expr ')'

```

å‡å¦‚ä½ æœ‰æƒŠä¸–æ™ºæ…§ï¼Œæœ‰ç€æƒŠäººçš„æ³¨æ„åŠ›ï¼Œä¸éš¾æ³¨æ„åˆ°æˆ‘ä»¬å¯ä»¥åƒä¸Šé¢ä¸€æ ·æ”¹é€ å½“å‰çš„è¯­æ³•ã€‚
è·å¾—ä¸€ä¸ªæ˜ç¡®çš„è§£æç»“æœã€‚

å¾ˆæ˜¾ç„¶ä¸Šé¢çš„è¯­æ³•è¶…å‡ºäº†å°å­¦æ•°å­¦å­¦ä¹ åå¸¦æ¥çš„ç›´è§‰ï¼Œæƒ³ä¸åˆ°ä¸€ç‚¹ğŸ¤ å•Šã€‚

æˆ‘~~åªæ˜¯å¡èŠ™å¡å¥³å£«çš„ç‹—ï¼Œåªæœ‰æåƒåœ¾æ¡¶çš„æ™ºæ…§~~ åªæœ‰ä¸€åŒ…é“å¾·å´‡é«˜çš„èµè®¸ğŸ‘ï¼Œæ²¡æœ‰æƒŠä¸–æ™ºæ…§

è¿™ä¸ªæ—¶å€™å¦‚æœä½ é˜…è¯»ä¹¦ç±ï¼Œæˆ–è€…åœ¨ç½‘ä¸ŠæŸ¥æ‰¾èµ„æ–™ï¼Œå¯ä»¥æ‰¾åˆ°ä¸€ä¸ªå«ä½œ Pratt Parse çš„ç®—æ³•ï¼Œ
é€šè¿‡åœ¨è§£æçš„æ—¶å€™å¼•å…¥è¿ç®—ç¬¦ä¼˜å…ˆçº§ï¼Œæ¥è§£å†³è¿™ä¸ªäºŒä¹‰æ€§é—®é¢˜, åŒæ—¶è¿ç®—ç¬¦ä¼˜å…ˆçº§æ˜¯å°å­¦
å°±å­¦è¿‡çš„ä¸œè¥¿ï¼Œéå¸¸çš„ç¬¦åˆç›´è§‰ã€‚æ¥ä¸‹æ¥å°±é€šè¿‡è¿™ä¸ªä¸œè¥¿æ¥è§£æè¿™ç§è¡¨è¾¾å¼ã€‚

## Pratt Parsing

é¦–å…ˆå®šä¹‰ä¸€ä¸ªå«ä½œ binding power çš„ä¸œè¥¿ï¼Œä¸€ä¸ªè¿ç®—ç¬¦çš„ä¼˜å…ˆçº§è¶Šé«˜ï¼Œé‚£ä¹ˆä»–çš„ binding power
æ›´å¼ºã€‚

æˆ‘ä»¬ç”¨ python å®šä¹‰ binding power å¦‚ä¸‹ï¼š

```python
{
    "s": 0,
    "+": 1,
    "-": 1,
    "*": 2,
    "/": 2,
}
```

å…¶ä¸­ S è¡¨ç¤ºè¡¨è¾¾å¼ä¸¤è¾¹çš„ binding power, è¿™ä¸ª binding power çš„ä½œç”¨å°±æ˜¯ç­‰ä¼šå„¿ç”¨æ¥å†³å®š
æ¯ä¸ªæ•°å­—æˆ–è€…å˜é‡ï¼Œå‡å¦‚ä¸¤è¾¹éƒ½æœ‰è¿ç®—ç¬¦çš„æ—¶å€™ï¼Œåº”è¯¥ä¼˜å…ˆå‚ä¸å“ªä¸ªè¿ç®—ç¬¦çš„è¿ç®—ã€‚
å¾ˆæ˜¾ç„¶æˆ‘ä»¬æ¯ä¸ªå˜é‡åº”è¯¥ä¼˜å…ˆå‚åŠ ä¼˜å…ˆçº§æ›´é«˜çš„è¿ç®—ã€‚

å‡å¦‚æˆ‘ä»¬æœ‰ä¸€ä¸ªè¡¨è¾¾å¼ `A + B * C`, æˆ‘ä»¬åœ¨è¿ç®—ç¬¦å’Œè¡¨è¾¾å¼çš„ä¸¤è¾¹
æ ‡è®°ä¸Šbinding power

```txt
   A       +       B       *       C
0     1        1       2       2         0
```

å¯¹äº B è¿™ä¸ªè¡¨è¾¾å¼å˜é‡ï¼Œå®ƒä¸¤è¾¹çš„ power å€¼ä¸º
1 å’Œ 2ï¼Œé‚£ä¹ˆå› ä¸ºå³è¾¹çš„ power æ›´å¤§ï¼Œé‚£ä¹ˆ B å°±ä¼šè¢«å³è¾¹çš„ä¹˜å·**å¸å¼•**è¿‡å»ï¼Œå»ä¼˜å…ˆå‚ä¸ä¹˜æ³•è¿ç®—ã€‚
åŒç†æˆ‘ä»¬å¯¹æ‰€æœ‰çš„
å˜é‡è¿›è¡ŒåŒæ ·çš„åˆ¤æ–­ï¼Œå¯ä»¥å¾—åˆ°å¦‚ä¸‹æ¯ä¸ªè¡¨è¾¾å¼ä¸­çš„å˜é‡ä¼˜å…ˆå‚ä¸è¿ç®—çš„ç»“æœï¼š

```txt
    A        +         B         *         C
0   ->   1        1    ->    2       2    <-     0
```

å¯ä»¥çœ‹åˆ° A ä¼˜å…ˆå‚åŠ åŠ æ³•ï¼ŒB å’Œ C ä¼˜å…ˆå‚åŠ ä¹˜æ³•è¿ç®—ã€‚
è¿™å¾ˆç¬¦åˆæˆ‘ä»¬å°å­¦å­¦è¿‡çš„æ•°å­¦çŸ¥è¯†ã€‚

ç„¶åä¹˜æ³•è¿ç®—çš„ä¸¤è¾¹éƒ½æœ‰å˜é‡è¢«å¸å¼•è¿‡æ¥äº†ï¼Œ
å‚ä¸è¿ç®—çš„æ‰€æœ‰æˆå‘˜éƒ½å·²ç»é›†é½ï¼Œå¯ä»¥æˆä¸ºä¸€ä¸ªå®Œæ•´çš„ç®—å¼ã€‚

ç„¶ååœ¨æˆ‘ä»¬çš„è§£æå™¨ä¸­ã€‚æˆ‘ä»¬å¯ä»¥å…ˆå¯¹ `B * C` æ„å»ºä¸€ä¸ªè¯­æ³•æ ‘äº†ã€‚

```txt
A   +    *
        / \
       B   C
```

æ¥ä¸‹æ¥æˆ‘ä»¬æŠŠ `B * C` è¿™æ£µå­æ ‘çœ‹æˆæ˜¯ä¸€ä¸ªå˜é‡, é‡å¤ä¹‹å‰çš„è¿‡ç¨‹ã€‚

```txt
0 -> 1    1  <-  0
  A     +     *
             / \
            B   C
```

ç°åœ¨åŠ æ³•å·¦å³æˆå‘˜é›†é½ï¼Œå¯ä»¥æ„å»ºè¯­æ³•æ ‘äº†ã€‚

æœ€ç»ˆå¾—åˆ°çš„è¯­æ³•æ ‘æ˜¯ï¼š

```txt
   +
  / \
 A   *
    / \
   B   C
```

é‚£ä¹ˆå¦‚æœæ˜¯ `A * B * C` è¿™ç§è¡¨è¾¾å¼å‘¢ï¼ŸB çš„ä¸¤è¾¹éƒ½æ˜¯ \*ï¼Œbinding power éƒ½ä¸€æ ·ã€‚
è¿™ä¸ªæ—¶å€™æˆ‘ä»¬è§„å®šå¦‚æœä¸¤è¾¹ power å€¼éƒ½ä¸€æ ·å¤§ï¼Œå°±ä¼˜å…ˆå‚åŠ å·¦è¾¹çš„è¿ç®—ã€‚
è¿™ä¹Ÿå¾ˆç¬¦åˆæˆ‘ä»¬å°å­¦æ•°å­¦çš„çŸ¥è¯†äº†, å…ˆç®— `A \* B`å†æœ€å`B \* C`ã€‚

å¤§æ¦‚çš„æµç¨‹å°±æ˜¯è¿™æ ·ï¼Œæ¥ä¸‹æ¥å°±æ˜¯å†™ä»£ç æ—¶é—´ã€‚

## Python å®ç°

æŒ‰ç…§ä¼ ç»Ÿæµç¨‹æ¥è¯´ï¼Œæˆ‘ä»¬è¦é¦–å…ˆç”¨ Lexer æŠŠæºä»£ç è½¬æ¢ä¸º Token æ•°ç»„ï¼Œç„¶åç”¨ Parser è¿›è¡Œè§£æ

### Lexer éƒ¨åˆ†

æœ¬æ¥è¿™éƒ¨åˆ†åº”è¯¥æ˜¯è¦ç”¨ lexer å°†æºä»£ç è§£æä¸º Token çš„ï¼Œä½†æ˜¯è¿™ä¸ªåœ°æ–¹æ¯•ç«Ÿä¸»è¦æ˜¯ä»‹ç»
Pratt Parsing ç®—æ³•çš„ï¼Œæ‰€ä»¥ lexer éƒ¨åˆ†å°±ç›´æ¥ç•¥è¿‡ï¼Œåªè¦çŸ¥é“å‡å¦‚æœ‰ä»£ç  `let x = 10;`
é‚£ä¹ˆ lexer ä¼šæŠŠä»–ä»¬è½¬æ¢ä¸ºä¸€ä¸ª Token å¯¹è±¡æ•°ç»„ï¼Œå†…å®¹ä¸º:

`[Token("let"), Token("x"), Token("="), Token("10"), Token(";"), Token(EOF)]`

> ä¸Šé¢çš„æ„é€ å‡½æ•°çœç•¥äº† token_type å‚æ•°

```python
class TokenType(Enum):
    NUMBER = auto()
    IDENT = auto()
    OPERTOR = auto()
    EOF = auto()


@dataclass
class Token:
    """Token å¯¹è±¡
    Attributes:
        TokenType: ç±»å‹
        TokenLiteral: å­—é¢é‡
    """

    token_type: TokenType
    literal: str
```

### Parser éƒ¨åˆ†

é¦–å…ˆæ˜¯ AST è¯­æ³•æ ‘ç»“ç‚¹çš„å®šä¹‰ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š

```python
class AstNode(ABC):
    """Ast ç»“ç‚¹æ¥å£"""

    @abstractmethod
    def to_string(self) -> str:
        pass


@dataclass
class Atom(AstNode):
    """Ast çš„å¶å­ç»“ç‚¹
    Attributes:
        token: å¶å­ç»“ç‚¹å­˜å‚¨çš„ token
    """

    token: Token

    def to_string(self) -> str:
        return self.token.literal


@dataclass
class BinaryExpression(AstNode):
    """Ast äºŒå…ƒè¿ç®—ç¬¦ç»“ç‚¹
    Attributes:
        operator: è¿ç®—ç¬¦
        left: å·¦å„¿å­
        right: å³å„¿å­
    """

    operator: str
    left: Optional[AstNode] = None
    right: Optional[AstNode] = None

    def to_string(self) -> str:
        assert self.left is not None and self.right is not None
        return f"({self.left.to_string()} {self.operator} {self.right.to_string()})"
```

å¶å­ç»“ç‚¹å’ŒäºŒå‰æ ‘ç»“ç‚¹éƒ½å®ç°äº† `AstNode` æ¥å£ï¼Œéƒ½æœ‰ä¸€ä¸ª `to_string` å‡½æ•°ç”¨æ¥æ‰“å°

æ¥ä¸‹æ¥å°±æ˜¯æ„å»º parser äº†

```python
@dataclass
class Parser:
    tokens: list[Token]
    token_pos: int = 0
    expression: Optional[AstNode] = None
    precedence_map: Dict[str, int] = field(
        default_factory=lambda: {
            "s": 0,
            "+": 1,
            "-": 1,
            "*": 2,
            "/": 2,
        }
    )
```

å¯ä»¥çœ‹åˆ°æˆ‘ä»¬è¿™ä¸ªåœ°æ–¹å­˜å‚¨äº† lexer ä¸­åˆ†æå‡ºæ¥çš„ tokens, ç”¨ `token_pos` è®°å½•å½“å‰
çš„ `Token` åˆ†æåˆ°äº†å“ªé‡Œï¼Œæœ€åè¿˜æœ‰ä¸€ä¸ª `Exression` è¡¨ç¤ºè¯­æ³•æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œæœ€å
æ˜¯ `precedence_map` ç”¨æ¥å­˜å‚¨è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ï¼Œç”¨æ¥è¡¨ç¤ºä»–ä»¬çš„ `binding power`

æ¥ä¸‹æ¥æˆ‘ä»¬éœ€è¦ 3 ä¸ªæˆå‘˜å‡½æ•°

```python
    def has_token(self) -> bool:
        return self.token_pos < len(self.tokens)

    def next_token(self) -> Token:
        token = self.tokens[self.token_pos]
        self.token_pos += 1
        return token

    def peek_token(self) -> Token:
        return self.tokens[self.token_pos]
```

å…¶ä¸­ `has_token` ç”¨æ¥æ£€æµ‹æ˜¯å¦è¿˜å‰©ä¸‹äº† token, `next_token` **æ¶ˆè€—æ‰**è¿˜æ²¡æœ‰è¯»å…¥çš„ Token
`peek_token` **ä»…ä»…è¿”å›** ä¸€ä¸ªè¿˜æ²¡æœ‰è¯»å…¥çš„ Token

```python
    def parse_expression(self) -> None:
        self.expression = self.__pratt_parse(self.precedence_map["s"])
```

æ¥ä¸‹æ¥è°ƒç”¨ç®—æ³•å‡½æ•°å¯¹è¡¨è¾¾å¼è¿›è¡Œè§£æ, å½“ç„¶æœ¬æ–‡çš„è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªé’æ˜¥ç‰ˆï¼Œ
å¹¶ä¸åŒ…å«ç±»ä¼¼ `-x` è¿™æ ·çš„è¡¨è¾¾å¼çš„è§£æã€‚

æœ€åå°±æ˜¯ä»£ç æ ¸å¿ƒå†…å®¹

```python
def __pratt_parse(self, left_precedence: int) -> Optional[AstNode]:
    root = Atom(self.next_token())

    # å¦‚æœå½“å‰è¿ç®—ç¬¦çš„ binding power ä¸€ç›´ä¸å¤Ÿå¤§ï¼Œè¢«å³è¾¹çš„è¿ç®—ç¬¦ç‹ ç‹ æ•è·â™‚
    while True:
        # æŸ¥çœ‹ä¸‹ä¸€ä¸ªæ˜¯å¦æ˜¯è¿ç®—ç¬¦
        peek_token = self.peek_token()
        if not self.has_token() or peek_token.token_type != TokenType.OPERTOR:
            break

        # å¦‚æœå½“å‰ token å·¦è¾¹è¿ç®—ç¬¦çš„ binding power è¶³å¤Ÿå¤§
        # é‚£ä¹ˆå½“å‰ token å°±ä¸ç”¨è¢«å³è¾¹çš„è¿ç®—ç¬¦æ•è·
        operator = peek_token.literal
        right_precedence = self.precedence_map[operator]
        if left_precedence >= right_precedence:
            break

        # æ„é€ äºŒå‰æ ‘
        root = BinaryExpression(
            operator=self.next_token().literal,
            left=root,
            right=self.__pratt_parse(self.precedence_map[operator]),
        )
    return root
```

æ¯”è¾ƒæŠ½è±¡ï¼Œè¿™é‡Œæ˜¯å»ºè®®æ‹¿åˆ°å®Œæ•´ä»£ç ä»¥åç”¨è°ƒè¯•å™¨ç‹ ç‹ è°ƒè¯•ï¼Œç”¨æ¥è¾…åŠ©ç†è§£ã€‚
æœ¬æ–‡å¤§æ¦‚ä»‹ç»ä¸€ä¸‹æµç¨‹

1. é¦–å…ˆè¯»å…¥ä¸€ä¸ª Token ä½œä¸ºå½“å‰æ ¹èŠ‚ç‚¹
2. ç„¶åç”¨ `while` å¾ªç¯çœ‹çœ‹å½“å‰çš„ Token å³è¾¹æ˜¯å¦è¿˜å‰©ä¸‹è¿ç®—ç¬¦æœ‰æ²¡æœ‰å¤„ç†ï¼Œå¦‚æœæœ‰ï¼Œé‚£ä¹ˆè¯´æ˜è¿ç®—ç¬¦å¯èƒ½æœ‰å³å„¿å­, å¯èƒ½éœ€è¦æ„é€ äºŒå‰æ ‘ç»“ç‚¹
3. åˆ¤æ–­è¯»å–åˆ°çš„è¿ç®—ç¬¦å’Œæ ¹èŠ‚ç‚¹å·¦ä¾§çš„ä¼˜å…ˆçº§è¿›è¡Œæ¯”è¾ƒï¼Œ**å¦‚æœå·¦ä¾§çš„ä¼˜å…ˆçº§å¤Ÿå¤§**ï¼Œé‚£ä¹ˆè¯´æ˜å½“å‰çš„æ ¹èŠ‚ç‚¹ä¸éœ€è¦è¢«å³ä¾§çš„è¿ç®—ç¬¦æ•è·ï¼Œç›´æ¥é€€å‡º
4. **å¦‚æœå³è¾¹çš„è¿ç®—ç¬¦ä¼˜å…ˆçº§é«˜**ï¼Œæ›´æœ‰ power â™‚ï¼Œé‚£ä¹ˆæˆ‘ä»¬å½“å‰çš„æ ¹èŠ‚ç‚¹å°±éœ€è¦å‚ä¸å³è¾¹çš„è¿ç®—ç¬¦çš„è®¡ç®—ï¼Œè¢«ç‹ ç‹ æ•è·ã€‚
5. è¢«æ•è·ä»¥åæ„å»ºäºŒå‰æ ‘ï¼Œå…¶ä¸­è¿ç®—ç¬¦æ˜¯å½“å‰æ ¹èŠ‚ç‚¹å³ä¾§çš„è¿ç®—ç¬¦ï¼Œæœ€åé€’å½’è°ƒç”¨å½“å‰çš„å‡½æ•°å¾—åˆ°å³å„¿å­ï¼Œå› ä¸ºå³ç»“ç‚¹å¯èƒ½å¹¶éåªæ˜¯ä¸€ä¸ªå¶å­ç»“ç‚¹ï¼Œ
   æœ‰ä¸€å®šå¯èƒ½æ˜¯ä¸€ä¸ªå­æ ‘, æ‰€ä»¥è¿™é‡Œè¦è¿›è¡Œé€’å½’ï¼Œæ¯”å¦‚è¯´è§£æ `A + B * C` çš„æ—¶å€™æ ¹èŠ‚ç‚¹çš„å³å„¿å­å°±æ˜¯è¡¨ç¤º `B * C` çš„å­æ ‘

### main function

æœ€åå°±æ˜¯å†™ main å‡½æ•°æ¥æµ‹è¯•äº†

```python
def main() -> None:
    tokens: list[Token] = [
        Token(TokenType.NUMBER, "1"),
        Token(TokenType.OPERTOR, "*"),
        Token(TokenType.NUMBER, "5"),
        Token(TokenType.OPERTOR, "*"),
        Token(TokenType.NUMBER, "5"),
        Token(TokenType.EOF, ""),
    ]

    parser = Parser(tokens)
    parser.parse_expression()  # ä½¿ç”¨ Pratt Parsing è¿›è¡Œåˆ†æ

    if parser.expression is not None:
        print(parser.expression.to_string())


if __name__ == "__main__":
    main()
```
